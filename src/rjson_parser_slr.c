// Generated by haxelib lex
#define LEXCHAR unsigned char
#define rlex_char(lex, i)     (((LEXCHAR *)(lex)->src)[i])
#define rlex_current(lex)     (((LEXCHAR *)(lex)->src) + (lex)->pos.min)

enum token {
	Eof = 0,
	CNull = 1,
	CTrue = 2,
	CFalse = 3,
	CFloat = 4,
	CString = 5,
	Comma = 6,
	DblDot = 7,
	LBrace = 8,
	RBrace = 9,
	LBracket = 10,
	RBracket = 11,
	OpSub = 12,
};

#include <stdio.h>
#include <stdlib.h>
#include "rjson.h"

// from rjson_parser.lex
int copy_lexchars(struct rlex *lex, int pos, int len, wchar_t *out, int outlen);

static int pos_wchars_compare (const void * a, const void * b)
{
	return ((struct pos_wchars *)a)->pos - ((struct pos_wchars *)b)->pos;
}

static void copy_to_chars(const LEXCHAR *source, int len, char *out, int outlen)
{
	if (len > outlen)
		len = outlen - 1;
	int i = 0;
	while (i < len) {
		out[i] = (unsigned char)source[i];
		i++;
	}
	out[len] = 0;
}

#define sto_parser(s)         container_of(s, struct rjson_parser, stream)
#define tpmin(t)              (t)->pos.min
#define tpmax(t)              (t)->pos.max

static double double_of_string(struct rstream *stream, const struct rstream_tok *t)
{
	char tmp[32];
	int len = tpmax(t) - tpmin(t);
	const LEXCHAR *source = stream->lex->src;
	copy_to_chars(source + tpmin(t), len, tmp, ARRAYSIZE(tmp));
	return strtod(tmp, NULL);
}

static rj_wchars wcs_of_string(struct rstream *stream, const struct rstream_tok *t)
{
	struct rarray *parray = &sto_parser(stream)->parray;
	struct pos_wchars *pwcs = &((struct pos_wchars){.pos = tpmin(t), .wcs = NULL});
	pwcs = bsearch(pwcs, parray->base, rarray_len(parray), sizeof(struct pos_wchars), pos_wchars_compare);
	if (pwcs == NULL) {
		fprintf(stderr, "some thing is wrong! %d-%d\n", tpmin(t), tpmax(t));
		exit(-1);
	}
	return pwcs->wcs;
}

static struct rjson_value *rjvalue_merge(struct rjson_value *parent, const struct rjson_value *reverses)
{
	if (reverses == NULL)
		return parent;
	struct rjson_vitem *item = VITEM_OF(reverses);
	struct rjson_vitem *next;
	while (item) {
		next = item->next;
		rjvalue_object_push(parent, item);
		item = next;
	}
	return parent;
}

#define RJSON    (&sto_parser(stream)->json)


const static int SLR_RDATA[] = {
3329, 3329, 3587, 3587, 3585, 3585, 3586, 3585, 3585, 3585, 3843, 3841, 3840, 4099, 4097, 4096, 4355
};

const static unsigned  char  _slrtable[] = {
// STATE 0
0x18,0x17,0x16,0x15,0x14,0x13,0xFF,0xFF,0x01,0xFF,0x04,0xFF,0x05,0xFF,0x0A,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 1
0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x08,
0xFF,0x0B,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 2
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 3
0xFF,0x17,0x16,0x15,0x14,0x13,0xFF,0xFF,0x01,0xFF,0x04,0xFF,0x05,0xFF,0x0E,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 4
0xFF,0x17,0x16,0x15,0x14,0x13,0xFF,0xFF,0x01,0xFF,0x04,0xFF,0x05,0xFF,0x11,0xFF,
0x06,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 5
0xFF,0xFF,0xFF,0xFF,0x12,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 6
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0xFF,0xFF,0xFF,0xFF,0x0F,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 7
0xFF,0x17,0x16,0x15,0x14,0x13,0xFF,0xFF,0x01,0xFF,0x04,0xFF,0x05,0xFF,0x10,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 8
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x09,0xFF,0xFF,0x0C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// STATE 9
0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0x0D,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
// EXIT
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0x09,0x08,0x07,0x05,0x04,0x06,0x0E,0x0D,
0x03,0x10,0x0A,0x02,0x0B,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0xFF,0xFF,0x0C,0xFF
};

#define SLR_EXIT(s)      (_slrtable[(352 - 1) - (s)])
#define SLR_TRANS(s, c)  (_slrtable[((s) * 32) + (c)])

void *rjson_parser_slrloop(struct rstream *stream, int begin, int exp);
#define rjson_parser_slrloop            slrloop

#define MAIN_BEGIN               0
#define MAIN_EXP                 13
#define rjson_parser_main(stream)   (struct rjson_value *)(slrloop(stream, 0, 13))


#define stream_offset(i)              (stream->head + (i))
#define stream_peek(i)                (rstream_peek(stream, i))
#define stream_junk(n)                (rstream_junk(stream, n))
#define stream_current(t)             (((LEXCHAR *)(stream->lex)->src) + t->pmin)

static void *slrcases(struct rstream *stream, int _q) {
	void *_ret = NULL;
	switch(_q) {

	case 0:
	{
		const struct rstream_tok *T1 = stream_offset(-1);
		const struct rjson_value * v = (struct rjson_value *) T1->value;
		_ret = (void *)(size_t)(v);
	}
	break;

	case 1:
	{
		const struct rstream_tok *T1 = stream_offset(-1);
		_ret = (void *)(size_t)(NULL);
	}
	break;

	case 2:
	{
		const struct rstream_tok *T1 = stream_offset(-3);
		const struct rstream_tok *T2 = stream_offset(-2);
		const struct rjson_value * a = (struct rjson_value *) T2->value;
		const struct rstream_tok *T3 = stream_offset(-1);
		struct rjson_value *object = rjvalue_object_new(RJSON);
		_ret = (void *)(size_t)(rjvalue_merge(object, a));
	}
	break;

	case 3:
	{
		const struct rstream_tok *T1 = stream_offset(-3);
		const struct rstream_tok *T2 = stream_offset(-2);
		const struct rjson_value * a = (struct rjson_value *) T2->value;
		const struct rstream_tok *T3 = stream_offset(-1);
		struct rjson_value *array = rjvalue_array_new(RJSON);
		_ret = (void *)(size_t)(rjvalue_merge(array, a));
	}
	break;

	case 4:
	{
		const struct rstream_tok *T1 = stream_offset(-1);
		const rj_wchars s = wcs_of_string(stream, T1);
		_ret = (void *)(size_t)(rjvalue_from_lwchars(RJSON, LWCHARS_OF(s)));
	}
	break;

	case 5:
	{
		const struct rstream_tok *T1 = stream_offset(-1);
		const double f = double_of_string(stream, T1);
		_ret = (void *)(size_t)(rjvalue_number(RJSON, f));
	}
	break;

	case 6:
	{
		const struct rstream_tok *T1 = stream_offset(-2);
		const struct rstream_tok *T2 = stream_offset(-1);
		const double f = double_of_string(stream, T2);
		_ret = (void *)(size_t)(rjvalue_number(RJSON, -f));
	}
	break;

	case 7:
	{
		const struct rstream_tok *T1 = stream_offset(-1);
		_ret = (void *)(size_t)(rjvalue_bool(RJSON, 0));
	}
	break;

	case 8:
	{
		const struct rstream_tok *T1 = stream_offset(-1);
		_ret = (void *)(size_t)(rjvalue_bool(RJSON, 1));
	}
	break;

	case 9:
	{
		const struct rstream_tok *T1 = stream_offset(-1);
		_ret = (void *)(size_t)(rjvalue_null(RJSON));
	}
	break;

	case 10:
	{
		const struct rstream_tok *T1 = stream_offset(-3);
		const struct rjson_value * a = (struct rjson_value *) T1->value;
		const struct rstream_tok *T2 = stream_offset(-2);
		const struct rstream_tok *T3 = stream_offset(-1);
		const struct rjson_value * i = (struct rjson_value *) T3->value;
		VITEM_OF(i)->next = VITEM_OF(a);
		_ret = (void *)(size_t)(i);
	}
	break;

	case 11:
	{
		const struct rstream_tok *T1 = stream_offset(-1);
		const struct rjson_value * i = (struct rjson_value *) T1->value;
		_ret = (void *)(size_t)(i);
	}
	break;

	case 12:
	{
		_ret = (void *)(size_t)(NULL);
	}
	break;

	case 13:
	{
		const struct rstream_tok *T1 = stream_offset(-3);
		const struct rjson_value * a = (struct rjson_value *) T1->value;
		const struct rstream_tok *T2 = stream_offset(-2);
		const struct rstream_tok *T3 = stream_offset(-1);
		const struct rjson_value * v = (struct rjson_value *) T3->value;
		VITEM_OF(v)->next = VITEM_OF(a);
		_ret = (void *)(size_t)(v);
	}
	break;

	case 14:
	{
		const struct rstream_tok *T1 = stream_offset(-1);
		const struct rjson_value * v = (struct rjson_value *) T1->value;
		_ret = (void *)(size_t)(v);
	}
	break;

	case 15:
	{
		_ret = (void *)(size_t)(NULL);
	}
	break;

	case 16:
	{
		const struct rstream_tok *T1 = stream_offset(-3);
		const rj_wchars key = wcs_of_string(stream, T1);
		const struct rstream_tok *T2 = stream_offset(-2);
		const struct rstream_tok *T3 = stream_offset(-1);
		const struct rjson_value * v = (struct rjson_value *) T3->value;
		VITEM_OF(v)->key = key;
		_ret = (void *)(size_t)(v);
	}
	break;

	default:
	{
		struct rstream_tok *t = stream_peek(0);
		struct rjson_parser *parser = sto_parser(stream);
		struct lncolumn lcn = crlf_get(&parser->crlfcnt, tpmin(t));
		int len = tpmax(t) - tpmin(t);
		int outlen = copy_lexchars(stream->lex, tpmin(t), len, NULL, 0);
		VLADecl(wchar_t, wcstr, outlen + 1);
		copy_lexchars(stream->lex, tpmin(t), len, wcstr, outlen);
		fprintf(stderr, "%ls:%d: characters %d-%d : UnExpected '%ls'\n",
		parser->filename, lcn.line, lcn.column, lcn.column + len, wcstr
		);
		exit(-1);
		_ret = (void *)(size_t)(NULL);
	}
	break;

	}
	return _ret;
}

// public function
void *rjson_parser_slrloop(struct rstream *stream, int state, int exp)
{
#define NRULES          17
#define NSEGS           10
#define INVALID         255

	struct rstream_tok *t;
	if (state >= 0) {
		t = rstream_reserve(stream);
		t->state = state;
	} else {
		t = stream_offset(-1);
		state = t->state;
	}
	void *value;
	int reduce;
	int q = INVALID;
	while (1) { FirstLoop:
		t = rstream_next(stream);
		state = SLR_TRANS(state, t->term);
		if (state >= NSEGS)
			break;
		t->state = state;
	}
	if (state == INVALID) {
		stream->head -= 1;
		state = stream_offset(-1)->state;
	}
	while (1) {
		q = SLR_EXIT(state);
		if (q >= NRULES) {
			
			return slrcases(stream, q);
		}
		value = slrcases(stream, q);
		reduce = SLR_RDATA[q];
		t = rstream_reduce(stream, reduce & 0xFF);
		t->term = reduce >> 8;
		if (t->term == exp) {
			stream->head -= 2;
			rstream_junk(stream, 2);
			return value;
		}
		t->value = value;
		state = SLR_TRANS(stream_offset(-2)->state, t->term);
		t->state = state;
		if (state < NSEGS)
			goto FirstLoop;
	}
	return slrcases(stream, q);

#undef NRULES
#undef NSEGS
#undef INVALID
#undef goto_cases
}
// undef
#undef stream_offset
#undef stream_peek
#undef stream_junk
#undef stream_current
#undef SLR_EXIT
#undef SLR_TRANS

#undef RJSON
#undef sto_parser
#undef tpmin
#undef tpmax

// auto generated by lex
void rjson_parser_init_lexeme(struct rlex* lex, LEXCHAR *src, int size);

void rjson_parser_init(struct rjson_parser *parser, wchar_t *filename, LEXCHAR *text, int len)
{
	// buffer, wcspool, nodepool, value
	rjson_init(&parser->json);

	// pos => string map init
	parser->parray = (struct rarray){.size = sizeof(struct pos_wchars), .base = NULL};

	// crlf counter init
	parser->crlfcnt = (struct crlf_counter){.csize = 128, .length = 0, .chunks = NULL};

	// filename, could be L""
	parser->filename = rj_wchars_fromwcs(&parser->json, filename, -1);

	// lex
	rjson_parser_init_lexeme(&parser->lex, text, len);

	// stream
	rstream_init(&parser->stream, &parser->lex);
}

void rjson_parser_release(struct rjson_parser *parser)
{
	rjson_release(&parser->json); // buffer, wcspool, nodepool
	rarray_release(&parser->parray);
	crlf_release(&parser->crlfcnt);
}

void rjson_parser_read(struct rjson_parser *parser)
{
	parser->json.value = rjson_parser_main(&parser->stream);
}
