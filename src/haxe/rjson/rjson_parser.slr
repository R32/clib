#include <stdio.h>
#include <stdlib.h>
#include "rjson.h"

// from rjson_parser.lex
int copy_lexchars(struct rlex *lex, int pos, int len, wchar_t *out, int outlen);

static int pos_wchars_compare (const void * a, const void * b)
{
	return ((struct pos_wchars *)a)->pos - ((struct pos_wchars *)b)->pos;
}

static void copy_to_chars(const LEXCHAR *source, int len, char *out, int outlen)
{
	if (len > outlen)
		len = outlen - 1;
	int i = 0;
	while (i < len) {
		out[i] = (unsigned char)source[i];
		i++;
	}
	out[len] = 0;
}

#define sto_parser(s)         container_of(s, struct rjson_parser, stream)
#define tpmin(t)              (t)->pos.min
#define tpmax(t)              (t)->pos.max

static double double_of_string(struct rstream *stream, const struct rstream_tok *t)
{
	char tmp[32];
	int len = tpmax(t) - tpmin(t);
	const LEXCHAR *source = stream->lex->src;
	copy_to_chars(source + tpmin(t), len, tmp, ARRAYSIZE(tmp));
	return strtod(tmp, NULL);
}

static rj_wchars wcs_of_string(struct rstream *stream, const struct rstream_tok *t)
{
	struct rarray *parray = &sto_parser(stream)->parray;
	struct pos_wchars *pwcs = &((struct pos_wchars){.pos = tpmin(t), .wcs = NULL});
	pwcs = bsearch(pwcs, parray->base, rarray_len(parray), sizeof(struct pos_wchars), pos_wchars_compare);
	if (pwcs == NULL) {
		fprintf(stderr, "some thing is wrong! %d-%d\n", tpmin(t), tpmax(t));
		exit(-1);
	}
	return pwcs->wcs;
}

static struct rjson_value *rjvalue_merge(struct rjson_value *parent, const struct rjson_value *reverses)
{
	if (reverses == NULL)
		return parent;
	struct rjson_vitem *item = VITEM_OF(reverses);
	struct rjson_vitem *next;
	while (item) {
		next = item->next;
		rjvalue_object_push(parent, item);
		item = next;
	}
	return parent;
}

#define RJSON    (&sto_parser(stream)->json)

%% // simple LR starts,

%START(main)
%DEF(struct rjson_value *)

%FUNC(CFloat , double, double_of_string)
%FUNC(CString, rj_wchars, wcs_of_string)

let main = function
| [v = value] -> 
	v
| [Eof] -> 
	NULL
| _ ->
	struct rstream_tok *t = stream_peek(0);
	struct rjson_parser *parser = sto_parser(stream);
	struct lncolumn lcn = crlf_get(&parser->crlfcnt, tpmin(t));
	int len = tpmax(t) - tpmin(t);

	int outlen = copy_lexchars(stream->lex, tpmin(t), len, NULL, 0);
	VLADecl(wchar_t, wcstr, outlen + 1);
	copy_lexchars(stream->lex, tpmin(t), len, wcstr, outlen);

	fprintf(stderr, "%ls:%d: characters %d-%d : UnExpected '%ls'\n",
		parser->filename, lcn.line, lcn.column, lcn.column + len, wcstr
	);
	exit(-1);
	NULL

let value = function
| ["{", a = pairs ,"}"] ->
	struct rjson_value *object = rjvalue_object_new(RJSON);
	rjvalue_merge(object, a)
| ["[", a = array ,"]"] ->
	struct rjson_value *array = rjvalue_array_new(RJSON);
	rjvalue_merge(array, a)
| [CString(s)] ->
	rjvalue_from_lwchars(RJSON, LWCHARS_OF(s))
| [CFloat(f)] ->
	rjvalue_number(RJSON, f)
| ["-", CFloat(f)] ->
	rjvalue_number(RJSON, -f)
| [CFalse] ->
	rjvalue_bool(RJSON, 0)
| [CTrue] ->
	rjvalue_bool(RJSON, 1)
| [CNull] ->
	rjvalue_null(RJSON)

let pairs = function
| [a = pairs, ",", i = item] ->
	VITEM_OF(i)->next = VITEM_OF(a); // reverse order
	i
| [i = item] ->
	i
| [] ->
	NULL

let array = function
| [a = array, ",", v = value] ->
	VITEM_OF(v)->next = VITEM_OF(a); // reverse order
	v
| [v = value] ->
	v
| [] ->
	NULL

let item = function
| [CString(key), ":", v = value] ->
	VITEM_OF(v)->key = key;
	v

%%
#undef RJSON
#undef sto_parser
#undef tpmin
#undef tpmax

// auto generated by lex
void rjson_parser_init_lexeme(struct rlex* lex, LEXCHAR *src, int size);

void rjson_parser_init(struct rjson_parser *parser, wchar_t *filename, LEXCHAR *text, int len)
{
	// buffer, wcspool, nodepool, value
	rjson_init(&parser->json);

	// pos => string map init
	parser->parray = (struct rarray){.size = sizeof(struct pos_wchars), .base = NULL};

	// crlf counter init
	parser->crlfcnt = (struct crlf_counter){.csize = 128, .length = 0, .chunks = NULL};

	// filename, could be L""
	parser->filename = rj_wchars_fromwcs(&parser->json, filename, -1);

	// lex
	rjson_parser_init_lexeme(&parser->lex, text, len);

	// stream
	rstream_init(&parser->stream, &parser->lex);
}

void rjson_parser_release(struct rjson_parser *parser)
{
	rjson_release(&parser->json); // buffer, wcspool, nodepool
	rarray_release(&parser->parray);
	crlf_release(&parser->crlfcnt);
}

void rjson_parser_read(struct rjson_parser *parser)
{
	parser->json.value = rjson_parser_main(&parser->stream);
}
